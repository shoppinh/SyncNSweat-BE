name: "Build and Deploy to Cloud Run"
concurrency:
  group: deploy-cloudrun-${{ github.ref }}
  cancel-in-progress: true
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  # Only actual secrets - infrastructure values come from Terraform outputs
  # Application secrets
  SECRET_KEY: "${{ secrets.SECRET_KEY }}"
  SPOTIFY_CLIENT_ID: "${{ secrets.SPOTIFY_CLIENT_ID }}"
  SPOTIFY_CLIENT_SECRET: "${{ secrets.SPOTIFY_CLIENT_SECRET }}"
  EXERCISE_API_KEY: "${{ secrets.EXERCISE_API_KEY }}"
  EXERCISE_API_HOST: "${{ secrets.EXERCISE_API_HOST }}"
  GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
  DEFAULT_SPOTIFY_USER_PASSWORD: "${{ secrets.DEFAULT_SPOTIFY_USER_PASSWORD }}"

jobs:
  deploy:
    runs-on: "ubuntu-latest"
    timeout-minutes: 30

    permissions:
      contents: "read"
      id-token: "write"

    steps:
      - name: "Checkout"
        uses: "actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332" # actions/checkout@v4

      - name: "Authenticate to Google Cloud (Workload Identity)"
        uses: "google-github-actions/auth@v2"
        with:
          workload_identity_provider: "${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          service_account: "${{ secrets.GCP_SERVICE_ACCOUNT }}"

      # Configure Workload Identity Federation and generate an access token.
      # See https://github.com/google-github-actions/auth for options.
      

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_wrapper: false  # Needed to parse outputs as JSON
        
      - name: Terraform Init
        working-directory: infra
        run: terraform init
        
      - name: Terraform Plan
        working-directory: infra
        run: |
          terraform plan \
            -var="project_id=${{ secrets.GCP_PROJECT_ID }}" \
            -var="region=${{ secrets.GCP_REGION }}" \
            -var="github_repo=${{ github.repository }}" \
            -var="db_password=${{ secrets.GCP_CLOUD_SQL_DB_PASSWORD }}"
            
      - name: Terraform Apply
        working-directory: infra
        run: |
          terraform apply -auto-approve \
            -var="project_id=${{ secrets.GCP_PROJECT_ID }}" \
            -var="region=${{ secrets.GCP_REGION }}" \
            -var="github_repo=${{ github.repository }}" \
            -var="db_password=${{ secrets.GCP_CLOUD_SQL_DB_PASSWORD }}"

      # Get ALL infrastructure values from Terraform outputs
      - name: "Get Terraform Outputs"
        id: tf
        working-directory: infra
        run: |
          echo "project_id=$(terraform output -raw project_id)" >> $GITHUB_OUTPUT
          echo "region=$(terraform output -raw region)" >> $GITHUB_OUTPUT
          echo "service_name=$(terraform output -raw cloud_run_service_name)" >> $GITHUB_OUTPUT
          echo "artifact_registry_url=$(terraform output -raw artifact_registry_url)" >> $GITHUB_OUTPUT
          echo "service_account=$(terraform output -raw service_account_email)" >> $GITHUB_OUTPUT
          echo "cloudrun_service_account=$(terraform output -raw cloudrun_service_account)" >> $GITHUB_OUTPUT
          echo "cloud_run_url=$(terraform output -raw cloud_run_url)" >> $GITHUB_OUTPUT
          echo "cloud_sql_connection=$(terraform output -raw cloud_sql_connection_name)" >> $GITHUB_OUTPUT
          echo "secret_names=$(terraform output -json secret_names)" >> $GITHUB_OUTPUT

      # Already authenticated above (needed for Terraform backend access).
      # Update secret VALUES in GCP Secret Manager (Terraform already created the resources)
      - name: "Update Secret Values in GCP Secret Manager"
        run: |
          # Get secret names from Terraform outputs
          SECRET_NAMES='${{ steps.tf.outputs.secret_names }}'
          
          # Function to update a secret value (assumes secret resource already exists from Terraform)
          update_secret_value() {
            SECRET_NAME=$1
            SECRET_VALUE=$2
            
            if [ -z "$SECRET_VALUE" ]; then
              echo "⚠️  Warning: No value provided for ${SECRET_NAME} - skipping"
              return
            fi
            
            echo "✓ Updating secret value: ${SECRET_NAME}"
            echo -n "${SECRET_VALUE}" | gcloud secrets versions add "${SECRET_NAME}" \
              --project="${{ steps.tf.outputs.project_id }}" \
              --data-file=-
          }
          
          # Update all secret values (only those used in application)
          # Construct a socket-style DATABASE_URI so Cloud Run uses the built-in Cloud SQL connector
          DB_USER="${{steps.tf.outputs.database_user}}"
          DB_NAME="${{steps.tf.outputs.database_name}}"
          DB_PASS="${{ secrets.GCP_CLOUD_SQL_DB_PASSWORD }}"
          CLOUD_SQL_INSTANCE="${{ steps.tf.outputs.cloud_sql_connection }}"
          DATABASE_URI_SOCKET="postgresql://${DB_USER}:${DB_PASS}@/${DB_NAME}?host=/cloudsql/${CLOUD_SQL_INSTANCE}"

          update_secret_value "DATABASE_URI" "${DATABASE_URI_SOCKET}"
          update_secret_value "SECRET_KEY" "${{ env.SECRET_KEY }}"
          update_secret_value "SPOTIFY_CLIENT_ID" "${{ env.SPOTIFY_CLIENT_ID }}"
          update_secret_value "SPOTIFY_CLIENT_SECRET" "${{ env.SPOTIFY_CLIENT_SECRET }}"
          update_secret_value "SPOTIFY_REDIRECT_URL" "${{ steps.tf.outputs.cloud_run_url }}"
          update_secret_value "EXERCISE_API_KEY" "${{ env.EXERCISE_API_KEY }}"
          update_secret_value "EXERCISE_API_HOST" "${{ env.EXERCISE_API_HOST }}"
          update_secret_value "API_URL" "${{ steps.tf.outputs.cloud_run_url }}"
          update_secret_value "GEMINI_API_KEY" "${{ env.GEMINI_API_KEY }}"
          update_secret_value "DEFAULT_SPOTIFY_USER_PASSWORD" "${{ env.DEFAULT_SPOTIFY_USER_PASSWORD }}"
          
          echo ""
          echo "✅ All secrets updated successfully"

      # Build & push the image via Cloud Build (offloads build work to GCP and uses Artifact Registry)
      - name: "Build and Push Container with Cloud Build"
        run: |-
          IMAGE="${{ steps.tf.outputs.artifact_registry_url }}/${{ steps.tf.outputs.service_name }}:${{ github.sha }}"
          
          echo "Building and pushing image: ${IMAGE}"
          gcloud builds submit \
            --project="${{ steps.tf.outputs.project_id }}" \
            --tag "${IMAGE}" \
            --service-account="${{ steps.tf.outputs.service_account }}" \
            --gcs-log-dir=gs://${{ secrets.GCP_BUCKET_NAME }} \
            .

      - name: "Deploy to Cloud Run"
        uses: "google-github-actions/deploy-cloudrun@v2"
        with:
          service: "${{ steps.tf.outputs.service_name }}"
          region: "${{ steps.tf.outputs.region }}"
          image: "${{ steps.tf.outputs.artifact_registry_url }}/${{ steps.tf.outputs.service_name }}:${{ github.sha }}"
          flags: |
            --port=8000
            --add-cloudsql-instances=${{ steps.tf.outputs.cloud_sql_connection }}
            --service-account="${{ steps.tf.outputs.cloudrun_service_account }}"
            --concurrency=50
            --memory=512Mi
          # Use full Secret Manager resource names for clarity and tighter access control
          secrets: |
            DATABASE_URI=DATABASE_URI:latest
            SECRET_KEY=SECRET_KEY:latest
            SPOTIFY_CLIENT_ID=SPOTIFY_CLIENT_ID:latest
            SPOTIFY_CLIENT_SECRET=SPOTIFY_CLIENT_SECRET:latest
            SPOTIFY_REDIRECT_URL=SPOTIFY_REDIRECT_URL:latest
            EXERCISE_API_KEY=EXERCISE_API_KEY:latest
            EXERCISE_API_HOST=EXERCISE_API_HOST:latest
            API_URL=API_URL:latest
            GEMINI_API_KEY=GEMINI_API_KEY:latest
            DEFAULT_SPOTIFY_USER_PASSWORD=DEFAULT_SPOTIFY_USER_PASSWORD:latest